{"version":3,"sources":["components/SectionContainer.jsx","utils/dates.js","components/TurnipsPage/SundayPriceForm.jsx","utils/predictions.js","components/TurnipsPage/Predictions.jsx","components/TurnipsPage/TablePrices.jsx","components/TurnipsPage/ResultForm.jsx","components/TurnipsPage/index.jsx"],"names":["SectionContainer","styled","div","dayjs","extend","isoWeek","getPreviousWeek","week","subtract","format","SundayPriceForm","onChange","currentWeek","value","isFirstTime","Container","Row","Col","sm","md","Input","type","name","id","placeholder","e","parseInt","currentTarget","size","offset","FormGroup","check","Label","checked","defaultProps","PATTERN","FLUCTUATING","LARGE_SPIKE","DECREASING","SMALL_SPIKE","PROBABILITY_MATRIX","range_length","range","clamp","x","min","max","Math","range_intersect","range1","range2","range_intersect_length","float_sum","input","sum","c","i","length","cur","t","abs","PDF","a","b","uniform","this","value_start","floor","value_end","ceil","total_length","prob","Array","range_of","idx","total_probability","start","end","min_value","max_value","start_idx","end_idx","slice","normalize","rate_decay_min","rate_decay_max","round","prefix","prefix_sum","push","prefix_float_sum","max_X","max_Y","newProb","left","right","numbers_to_sum","Predictor","prices","first_buy","previous_pattern","fudge_factor","val","trunc","given_price","buy_price","minimum_rate_from_given_and_base","maximum_rate_from_given_and_base","rate","basePrice","intceil","generator","probability","it","given_prices","predicted_prices","rate_min","rate_max","rate_range","min_pred","get_price","max_pred","isNaN","rate_range_from_given_and_base","start_rate_min","start_rate_max","rate_pdf","real_rate_range","range_limit","decay","middle_price","left_price","right_price","price","rate2_range","F","ZZ","log","A","B","C","Z1","Z2","PY","high_phase_1_len","dec_phase_1_len","high_phase_2_len","dec_phase_2_len","high_phase_3_len","generate_individual_random_price","generate_decreasing_random_price","Error","prev_length","pattern_number","multiply_generator_probability","generate_pattern_0_with_lengths","peak_start","min_randoms","max_randoms","generate_pattern_1_with_peak","generate_peak_price","generate_pattern_3_with_peak","Number","sell_prices","generate_pattern_fns","generate_pattern_0","generate_pattern_1","generate_pattern_2","generate_pattern_3","transition_probability","get_transition_probability","bind","temp_sell_prices","generate_all_patterns","generated_possibilities","from","generate_possibilities","reduce","acc","poss","weekMins","weekMaxes","day","weekGuaranteedMinimum","weekMax","category_totals","filter","map","previous","current","pos","category_total_probability","sort","global_min_max","unshift","PATTERN_DESCRIPTION","Line","tr","p","selected","Predictions","buyPrice","sellPrices","displayEstimate","selectedLines","lastWeekPattern","renderPercentage","percent","isFinite","toPrecision","possibilities","useMemo","NaN","every","s","analyze_possibilities","style","marginBottom","display","justifyContent","ListGroup","horizontal","previousPattern","newValue","ListGroupItem","key","renderPatternProbabilities","Table","hover","responsive","colSpan","d","mins","maxs","days","JSON","stringify","isSelected","findIndex","v","onClick","shortid","generate","newObj","renderValue","className","renderDays","renderPatterns","TablePrices","values","savePrice","reset","renderInput","find","when","trim","replace","toLowerCase","field","borderless","textAlign","Button","ResultForm","quantity","pattern","sellPrice","sundayPrice","useState","isOpen","setIsOpen","result","setResult","useEffect","handleChange","color","Collapse","Card","CardBody","row","for","Object","keys","disabled","Wrapper","ChartContainer","LABELS","TurnipsPage","history","useHistory","location","useLocation","useLocalStorage","turnips","setTurnips","setCurrentWeek","setSundayPrice","myTownData","setMyTownData","setIsFirstTime","selectedPredictions","setSelectedPredictions","quantityBought","setQuantityBought","setPattern","setSellPrice","setLastWeekPattern","queryObj","qs","parse","search","refDate","date","startOf","DateUtils","lastWeek","weekValues","graph","qty","updateLocalStorage","newWeekValues","oldValue","obj","formateLabelName","l","getFormatedData","defaultValue","simpleLineChartData","labels","series","options","fullWidth","chartPadding","scaleMinSpace","height","onlyInteger","plugins","Chartist","tooltip","anchorToPoint","appendToBody","changeWeek","next","newDate","add","pathname","flexDirection","ButtonGroup","marginLeft","fontStyle","href","rel","target","intValue","formatedWhen","index","order","indexOf","newData","splice","data"],"mappings":"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","file":"static/js/11.5a2c5c27.chunk.js","sourcesContent":["import styled from 'styled-components';\n\nconst SectionContainer = styled.div`\n  background-color: #f8f8f0;\n  border-radius: 10px;\n  padding: 2px 5px;\n`;\n\nexport default SectionContainer;\n","import dayjs from 'dayjs';\nimport isoWeek from 'dayjs/plugin/isoWeek';\n\ndayjs.extend(isoWeek);\n\n/**\n * if refDate is a sunday, then returns refDate, otherwise we get the previous sunday\n */\nexport const getSundayDateForWeek = (refDate) => {\n  const date = dayjs(`${refDate}T12:00:00.000Z`);\n  const d = dayjs(date).day();\n  if (d === 0) return dayjs(date).format('YYYY-MM-DD');\n  const currentWeek = dayjs(date).startOf('week').format('YYYY-MM-DD');\n  return currentWeek;\n};\n\nexport const getNextWeek = (week) => dayjs(week).add(1, 'week').format('YYYY-MM-DD');\n\nexport const getPreviousWeek = (week) => dayjs(week).subtract(1, 'week').format('YYYY-MM-DD');\n","import React from 'react';\n// import styled from 'styled-components';\nimport {\n  Input, Row, Col, FormGroup, Label, Container,\n} from 'reactstrap';\nimport dayjs from 'dayjs';\nimport PropTypes from 'prop-types';\n\nconst propTypes = {\n  onChange: PropTypes.func.isRequired,\n  isFirstTime: PropTypes.bool,\n  currentWeek: PropTypes.string,\n  value: PropTypes.number,\n};\n\nconst defaultProps = {\n  value: '',\n  isFirstTime: false,\n  currentWeek: null,\n};\n\nconst SundayPriceForm = ({\n  onChange, currentWeek, value, isFirstTime,\n}) => {\n  const renderDate = () => (\n    <strong>\n      Sunday&nbsp;\n      {dayjs(currentWeek).format('DD MMMM YYYY')}\n    </strong>\n  );\n\n  return (\n    <Container>\n      <Row>\n        <Col sm=\"12\" md=\"6\">\n          Daisy Mae&apos;s Turnip price in your town on&nbsp;\n          {renderDate()}\n        </Col>\n        <Col sm=\"12\" md=\"6\">\n          <Input\n            type=\"number\"\n            name=\"sundayPrice\"\n            id=\"sundayPrice\"\n            value={value === 0 ? '' : value}\n            placeholder=\"--\"\n            onChange={(e) => onChange('price', parseInt(e.currentTarget.value, 10))}\n          />\n        </Col>\n      </Row>\n      <Row>\n        <Col sm=\"12\" md={{ size: 6, offset: 6 }}>\n          <FormGroup check>\n            <Label check>\n              <Input\n                type=\"checkbox\"\n                onChange={(e) => onChange('firstTime', e.currentTarget.checked)}\n                checked={isFirstTime}\n              />\n            &nbsp;First time buying\n            </Label>\n          </FormGroup>\n        </Col>\n      </Row>\n    </Container>\n  );\n};\n\nSundayPriceForm.propTypes = propTypes;\nSundayPriceForm.defaultProps = defaultProps;\n\nexport default SundayPriceForm;\n","/* eslint-disable */\n\nexport const PATTERN = {\n  FLUCTUATING: 0,\n  LARGE_SPIKE: 1,\n  DECREASING: 2,\n  SMALL_SPIKE: 3,\n};\n\nconst PROBABILITY_MATRIX = {\n  [PATTERN.FLUCTUATING]: {\n    [PATTERN.FLUCTUATING]: 0.20,\n    [PATTERN.LARGE_SPIKE]: 0.30,\n    [PATTERN.DECREASING]: 0.15,\n    [PATTERN.SMALL_SPIKE]: 0.35,\n  },\n  [PATTERN.LARGE_SPIKE]: {\n    [PATTERN.FLUCTUATING]: 0.50,\n    [PATTERN.LARGE_SPIKE]: 0.05,\n    [PATTERN.DECREASING]: 0.20,\n    [PATTERN.SMALL_SPIKE]: 0.25,\n  },\n  [PATTERN.DECREASING]: {\n    [PATTERN.FLUCTUATING]: 0.25,\n    [PATTERN.LARGE_SPIKE]: 0.45,\n    [PATTERN.DECREASING]: 0.05,\n    [PATTERN.SMALL_SPIKE]: 0.25,\n  },\n  [PATTERN.SMALL_SPIKE]: {\n    [PATTERN.FLUCTUATING]: 0.45,\n    [PATTERN.LARGE_SPIKE]: 0.25,\n    [PATTERN.DECREASING]: 0.15,\n    [PATTERN.SMALL_SPIKE]: 0.15,\n  },\n};\n\nconst RATE_MULTIPLIER = 10000;\n\nfunction range_length(range) {\n  return range[1] - range[0];\n}\n\nfunction clamp(x, min, max) {\n  return Math.min(Math.max(x, min), max);\n}\n\nfunction range_intersect(range1, range2) {\n  if (range1[0] > range2[1] || range1[1] < range2[0]) {\n    return null;\n  }\n  return [Math.max(range1[0], range2[0]), Math.min(range1[1], range2[1])];\n}\n\nfunction range_intersect_length(range1, range2) {\n  if (range1[0] > range2[1] || range1[1] < range2[0]) {\n    return 0;\n  }\n  return range_length(range_intersect(range1, range2));\n}\n\n/**\n * Accurately sums a list of floating point numbers.\n * See https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements\n * for more information.\n * @param {number[]} input\n * @returns {number} The sum of the input.\n */\nfunction float_sum(input) {\n  // Uses the improved Kahanâ€“Babuska algorithm introduced by Neumaier.\n  let sum = 0;\n  // The \"lost bits\" of sum.\n  let c = 0;\n  for (let i = 0; i < input.length; i++) {\n    const cur = input[i];\n    const t = sum + cur;\n    if (Math.abs(sum) >= Math.abs(cur)) {\n      c += (sum - t) + cur;\n    } else {\n      c += (cur - t) + sum;\n    }\n    sum = t;\n  }\n  return sum + c;\n}\n\n/**\n * Accurately returns the prefix sum of a list of floating point numbers.\n * See https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements\n * for more information.\n * @param {number[]} input\n * @returns {[number, number][]} The prefix sum of the input, such that\n * output[i] = [sum of first i integers, error of the sum].\n * The \"true\" prefix sum is equal to the sum of the pair of numbers, but it is\n * explicitly returned as a pair of numbers to ensure that the error portion\n * isn't lost when subtracting prefix sums.\n */\nfunction prefix_float_sum(input) {\n  const prefix_sum = [[0, 0]];\n  let sum = 0;\n  let c = 0;\n  for (let i = 0; i < input.length; i++) {\n    const cur = input[i];\n    const t = sum + cur;\n    if (Math.abs(sum) >= Math.abs(cur)) {\n      c += (sum - t) + cur;\n    } else {\n      c += (cur - t) + sum;\n    }\n    sum = t;\n    prefix_sum.push([sum, c]);\n  }\n  return prefix_sum;\n}\n\n/*\n * Probability Density Function of rates.\n * Since the PDF is continuous*, we approximate it by a discrete probability function:\n *   the value in range [x, x + 1) has a uniform probability\n *   prob[x - value_start];\n *\n * Note that we operate all rate on the (* RATE_MULTIPLIER) scale.\n *\n * (*): Well not really since it only takes values that \"float\" can represent in some form, but the\n * space is too large to compute directly in JS.\n */\nclass PDF {\n  /**\n   * Initialize a PDF in range [a, b], a and b can be non-integer.\n   * if uniform is true, then initialize the probability to be uniform, else initialize to a\n   * all-zero (invalid) PDF.\n   * @param {number} a - Left end-point.\n   * @param {number} b - Right end-point end-point.\n   * @param {boolean} uniform - If true, initialise with the uniform distribution.\n   */\n  constructor(a, b, uniform = true) {\n    // We need to ensure that [a, b] is fully contained in [value_start, value_end].\n    /** @type {number} */\n    this.value_start = Math.floor(a);\n    /** @type {number} */\n    this.value_end = Math.ceil(b);\n    const range = [a, b];\n    const total_length = range_length(range);\n    /** @type {number[]} */\n    this.prob = Array(this.value_end - this.value_start);\n    if (uniform) {\n      for (let i = 0; i < this.prob.length; i++) {\n        this.prob[i] =\n          range_intersect_length(this.range_of(i), range) / total_length;\n      }\n    }\n  }\n\n  /**\n   * Calculates the interval represented by this.prob[idx]\n   * @param {number} idx - The index of this.prob\n   * @returns {[number, number]} The interval representing this.prob[idx].\n   */\n  range_of(idx) {\n    // We intentionally include the right end-point of the range.\n    // The probability of getting exactly an endpoint is zero, so we can assume\n    // the \"probability ranges\" are \"touching\".\n    return [this.value_start + idx, this.value_start + idx + 1];\n  }\n\n  min_value() {\n    return this.value_start;\n  }\n\n  max_value() {\n    return this.value_end;\n  }\n\n  /**\n   * @returns {number} The sum of probabilities before normalisation.\n   */\n  normalize() {\n    const total_probability = float_sum(this.prob);\n    for (let i = 0; i < this.prob.length; i++) {\n      this.prob[i] /= total_probability;\n    }\n    return total_probability;\n  }\n\n  /*\n   * Limit the values to be in the range, and return the probability that the value was in this\n   * range.\n   */\n  range_limit(range) {\n    let [start, end] = range;\n    start = Math.max(start, this.min_value());\n    end = Math.min(end, this.max_value());\n    if (start >= end) {\n      // Set this to invalid values\n      this.value_start = this.value_end = 0;\n      this.prob = [];\n      return 0;\n    }\n    start = Math.floor(start);\n    end = Math.ceil(end);\n\n    const start_idx = start - this.value_start;\n    const end_idx = end - this.value_start;\n    for (let i = start_idx; i < end_idx; i++) {\n      this.prob[i] *= range_intersect_length(this.range_of(i), range);\n    }\n\n    this.prob = this.prob.slice(start_idx, end_idx);\n    this.value_start = start;\n    this.value_end = end;\n\n    // The probability that the value was in this range is equal to the total\n    // sum of \"un-normalised\" values in the range.\n    return this.normalize();\n  }\n\n  /**\n   * Subtract the PDF by a uniform distribution in [rate_decay_min, rate_decay_max]\n   *\n   * For simplicity, we assume that rate_decay_min and rate_decay_max are both integers.\n   * @param {number} rate_decay_min\n   * @param {number} rate_decay_max\n   * @returns {void}\n   */\n  decay(rate_decay_min, rate_decay_max) {\n    // In case the arguments aren't integers, round them to the nearest integer.\n    rate_decay_min = Math.round(rate_decay_min);\n    rate_decay_max = Math.round(rate_decay_max);\n    // The sum of this distribution with a uniform distribution.\n    // Let's assume that both distributions start at 0 and X = this dist,\n    // Y = uniform dist, and Z = X + Y.\n    // Let's also assume that X is a \"piecewise uniform\" distribution, so\n    // x(i) = this.prob[Math.floor(i)] - which matches our implementation.\n    // We also know that y(i) = 1 / max(Y) - as we assume that min(Y) = 0.\n    // In the end, we're interested in:\n    // Pr(i <= Z < i+1) where i is an integer\n    // = int. x(val) * Pr(i-val <= Y < i-val+1) dval from 0 to max(X)\n    // = int. x(floor(val)) * Pr(i-val <= Y < i-val+1) dval from 0 to max(X)\n    // = sum val from 0 to max(X)-1\n    //     x(val) * f_i(val) / max(Y)\n    // where f_i(val) =\n    // 0.5 if i-val = 0 or max(Y), so val = i-max(Y) or i\n    // 1.0 if 0 < i-val < max(Y), so i-max(Y) < val < i\n    // as x(val) is \"constant\" for each integer step, so we can consider the\n    // integral in integer steps.\n    // = sum val from max(0, i-max(Y)) to min(max(X)-1, i)\n    //     x(val) * f_i(val) / max(Y)\n    // for example, max(X)=1, max(Y)=10, i=5\n    // = sum val from max(0, 5-10)=0 to min(1-1, 5)=0\n    //     x(val) * f_i(val) / max(Y)\n    // = x(0) * 1 / 10\n\n    // Get a prefix sum / CDF of this so we can calculate sums in O(1).\n    const prefix = prefix_float_sum(this.prob);\n    const max_X = this.prob.length;\n    const max_Y = rate_decay_max - rate_decay_min;\n    const newProb = Array(this.prob.length + max_Y);\n    for (let i = 0; i < newProb.length; i++) {\n      // Note that left and right here are INCLUSIVE.\n      const left = Math.max(0, i - max_Y);\n      const right = Math.min(max_X - 1, i);\n      // We want to sum, in total, prefix[right+1], -prefix[left], and subtract\n      // the 0.5s if necessary.\n      // This may involve numbers of differing magnitudes, so use the float sum\n      // algorithm to sum these up.\n      const numbers_to_sum = [\n        prefix[right + 1][0], prefix[right + 1][1],\n        -prefix[left][0], -prefix[left][1],\n      ];\n      if (left === i - max_Y) {\n        // Need to halve the left endpoint.\n        numbers_to_sum.push(-this.prob[left] / 2);\n      }\n      if (right === i) {\n        // Need to halve the right endpoint.\n        // It's guaranteed that we won't accidentally \"halve\" twice,\n        // as that would require i-max_Y = i, so max_Y = 0 - which is\n        // impossible.\n        numbers_to_sum.push(-this.prob[right] / 2);\n      }\n      newProb[i] = float_sum(numbers_to_sum) / max_Y;\n    }\n\n    this.prob = newProb;\n    this.value_start -= rate_decay_max;\n    this.value_end -= rate_decay_min;\n    // No need to normalise, as it is guaranteed that the sum of this.prob is 1.\n  }\n}\n\nclass Predictor {\n\n  constructor(prices, first_buy, previous_pattern) {\n    // The reverse-engineered code is not perfectly accurate, especially as it's not\n    // 32-bit ARM floating point. So, be tolerant of slightly unexpected inputs\n    this.fudge_factor = 0;\n    this.prices = prices;\n    this.first_buy = first_buy;\n    this.previous_pattern = previous_pattern;\n  }\n\n  intceil(val) {\n    return Math.trunc(val + 0.99999);\n  }\n\n  minimum_rate_from_given_and_base(given_price, buy_price) {\n    return RATE_MULTIPLIER * (given_price - 0.99999) / buy_price;\n  }\n\n  maximum_rate_from_given_and_base(given_price, buy_price) {\n    return RATE_MULTIPLIER * (given_price + 0.00001) / buy_price;\n  }\n\n  rate_range_from_given_and_base(given_price, buy_price) {\n    return [\n      this.minimum_rate_from_given_and_base(given_price, buy_price),\n      this.maximum_rate_from_given_and_base(given_price, buy_price)\n    ];\n  }\n\n  get_price(rate, basePrice) {\n    return this.intceil(rate * basePrice / RATE_MULTIPLIER);\n  }\n\n  * multiply_generator_probability(generator, probability) {\n    for (const it of generator) {\n      yield { ...it, probability: it.probability * probability };\n    }\n  }\n\n  /*\n   * This corresponds to the code:\n   *   for (int i = start; i < start + length; i++)\n   *   {\n   *     sellPrices[work++] =\n   *       intceil(randfloat(rate_min / RATE_MULTIPLIER, rate_max / RATE_MULTIPLIER) * basePrice);\n   *   }\n   *\n   * Would return the conditional probability given the given_prices, and modify\n   * the predicted_prices array.\n   * If the given_prices won't match, returns 0.\n   */\n  generate_individual_random_price(\n    given_prices, predicted_prices, start, length, rate_min, rate_max) {\n    rate_min *= RATE_MULTIPLIER;\n    rate_max *= RATE_MULTIPLIER;\n\n    const buy_price = given_prices[0];\n    const rate_range = [rate_min, rate_max];\n    let prob = 1;\n\n    for (let i = start; i < start + length; i++) {\n      let min_pred = this.get_price(rate_min, buy_price);\n      let max_pred = this.get_price(rate_max, buy_price);\n      if (!isNaN(given_prices[i])) {\n        if (given_prices[i] < min_pred - this.fudge_factor || given_prices[i] > max_pred + this.fudge_factor) {\n          // Given price is out of predicted range, so this is the wrong pattern\n          return 0;\n        }\n        // TODO: How to deal with probability when there's fudge factor?\n        // Clamp the value to be in range now so the probability won't be totally biased to fudged values.\n        const real_rate_range =\n          this.rate_range_from_given_and_base(clamp(given_prices[i], min_pred, max_pred), buy_price);\n        prob *= range_intersect_length(rate_range, real_rate_range) /\n          range_length(rate_range);\n        min_pred = given_prices[i];\n        max_pred = given_prices[i];\n      }\n\n      predicted_prices.push({\n        min: min_pred,\n        max: max_pred,\n      });\n    }\n    return prob;\n  }\n\n  /*\n   * This corresponds to the code:\n   *   rate = randfloat(start_rate_min, start_rate_max);\n   *   for (int i = start; i < start + length; i++)\n   *   {\n   *     sellPrices[work++] = intceil(rate * basePrice);\n   *     rate -= randfloat(rate_decay_min, rate_decay_max);\n   *   }\n   *\n   * Would return the conditional probability given the given_prices, and modify\n   * the predicted_prices array.\n   * If the given_prices won't match, returns 0.\n   */\n  generate_decreasing_random_price(\n    given_prices, predicted_prices, start, length, start_rate_min,\n    start_rate_max, rate_decay_min, rate_decay_max) {\n    start_rate_min *= RATE_MULTIPLIER;\n    start_rate_max *= RATE_MULTIPLIER;\n    rate_decay_min *= RATE_MULTIPLIER;\n    rate_decay_max *= RATE_MULTIPLIER;\n\n    const buy_price = given_prices[0];\n    let rate_pdf = new PDF(start_rate_min, start_rate_max);\n    let prob = 1;\n\n    for (let i = start; i < start + length; i++) {\n      let min_pred = this.get_price(rate_pdf.min_value(), buy_price);\n      let max_pred = this.get_price(rate_pdf.max_value(), buy_price);\n      if (!isNaN(given_prices[i])) {\n        if (given_prices[i] < min_pred - this.fudge_factor || given_prices[i] > max_pred + this.fudge_factor) {\n          // Given price is out of predicted range, so this is the wrong pattern\n          return 0;\n        }\n        // TODO: How to deal with probability when there's fudge factor?\n        // Clamp the value to be in range now so the probability won't be totally biased to fudged values.\n        const real_rate_range =\n          this.rate_range_from_given_and_base(clamp(given_prices[i], min_pred, max_pred), buy_price);\n        prob *= rate_pdf.range_limit(real_rate_range);\n        if (prob == 0) {\n          return 0;\n        }\n        min_pred = given_prices[i];\n        max_pred = given_prices[i];\n      }\n\n      predicted_prices.push({\n        min: min_pred,\n        max: max_pred,\n      });\n\n      rate_pdf.decay(rate_decay_min, rate_decay_max);\n    }\n    return prob;\n  }\n\n\n  /*\n   * This corresponds to the code:\n   *   rate = randfloat(rate_min, rate_max);\n   *   sellPrices[work++] = intceil(randfloat(rate_min, rate) * basePrice) - 1;\n   *   sellPrices[work++] = intceil(rate * basePrice);\n   *   sellPrices[work++] = intceil(randfloat(rate_min, rate) * basePrice) - 1;\n   *\n   * Would return the conditional probability given the given_prices, and modify\n   * the predicted_prices array.\n   * If the given_prices won't match, returns 0.\n   */\n  generate_peak_price(\n    given_prices, predicted_prices, start, rate_min, rate_max) {\n    rate_min *= RATE_MULTIPLIER;\n    rate_max *= RATE_MULTIPLIER;\n\n    const buy_price = given_prices[0];\n    let prob = 1;\n    let rate_range = [rate_min, rate_max];\n\n    // * Calculate the probability first.\n    // Prob(middle_price)\n    const middle_price = given_prices[start + 1];\n    if (!isNaN(middle_price)) {\n      const min_pred = this.get_price(rate_min, buy_price);\n      const max_pred = this.get_price(rate_max, buy_price);\n      if (middle_price < min_pred - this.fudge_factor || middle_price > max_pred + this.fudge_factor) {\n        // Given price is out of predicted range, so this is the wrong pattern\n        return 0;\n      }\n      // TODO: How to deal with probability when there's fudge factor?\n      // Clamp the value to be in range now so the probability won't be totally biased to fudged values.\n      const real_rate_range =\n        this.rate_range_from_given_and_base(clamp(middle_price, min_pred, max_pred), buy_price);\n      prob *= range_intersect_length(rate_range, real_rate_range) /\n        range_length(rate_range);\n      if (prob == 0) {\n        return 0;\n      }\n\n      rate_range = range_intersect(rate_range, real_rate_range);\n    }\n\n    const left_price = given_prices[start];\n    const right_price = given_prices[start + 2];\n    // Prob(left_price | middle_price), Prob(right_price | middle_price)\n    //\n    // A = rate_range[0], B = rate_range[1], C = rate_min, X = rate, Y = randfloat(rate_min, rate)\n    // rate = randfloat(A, B); sellPrices[work++] = intceil(randfloat(C, rate) * basePrice) - 1;\n    //\n    // => X->U(A,B), Y->U(C,X), Y-C->U(0,X-C), Y-C->U(0,1)*(X-C), Y-C->U(0,1)*U(A-C,B-C),\n    // let Z=Y-C,  Z1=A-C, Z2=B-C, Z->U(0,1)*U(Z1,Z2)\n    // Prob(Z<=t) = integral_{x=0}^{1} [min(t/x,Z2)-min(t/x,Z1)]/ (Z2-Z1)\n    // let F(t, ZZ) = integral_{x=0}^{1} min(t/x, ZZ)\n    //    1. if ZZ < t, then min(t/x, ZZ) = ZZ -> F(t, ZZ) = ZZ\n    //    2. if ZZ >= t, then F(t, ZZ) = integral_{x=0}^{t/ZZ} ZZ + integral_{x=t/ZZ}^{1} t/x\n    //                                 = t - t log(t/ZZ)\n    // Prob(Z<=t) = (F(t, Z2) - F(t, Z1)) / (Z2 - Z1)\n    // Prob(Y<=t) = Prob(Z>=t-C)\n    for (const price of [left_price, right_price]) {\n      if (isNaN(price)) {\n        continue;\n      }\n      const min_pred = this.get_price(rate_min, buy_price) - 1;\n      const max_pred = this.get_price(rate_range[1], buy_price) - 1;\n      if (price < min_pred - this.fudge_factor || price > max_pred + this.fudge_factor) {\n        // Given price is out of predicted range, so this is the wrong pattern\n        return 0;\n      }\n      // TODO: How to deal with probability when there's fudge factor?\n      // Clamp the value to be in range now so the probability won't be totally biased to fudged values.\n      const rate2_range = this.rate_range_from_given_and_base(clamp(price, min_pred, max_pred) + 1, buy_price);\n      const F = (t, ZZ) => {\n        if (t <= 0) {\n          return 0;\n        }\n        return ZZ < t ? ZZ : t - t * (Math.log(t) - Math.log(ZZ));\n      };\n      const [A, B] = rate_range;\n      const C = rate_min;\n      const Z1 = A - C;\n      const Z2 = B - C;\n      const PY = (t) => (F(t - C, Z2) - F(t - C, Z1)) / (Z2 - Z1);\n      prob *= PY(rate2_range[1]) - PY(rate2_range[0]);\n      if (prob == 0) {\n        return 0;\n      }\n    }\n\n    // * Then generate the real predicted range.\n    // We're doing things in different order then how we calculate probability,\n    // since forward prediction is more useful here.\n    //\n    // Main spike 1\n    let min_pred = this.get_price(rate_min, buy_price) - 1;\n    let max_pred = this.get_price(rate_max, buy_price) - 1;\n    if (!isNaN(given_prices[start])) {\n      min_pred = given_prices[start];\n      max_pred = given_prices[start];\n    }\n    predicted_prices.push({\n      min: min_pred,\n      max: max_pred,\n    });\n\n    // Main spike 2\n    min_pred = predicted_prices[start].min;\n    max_pred = this.get_price(rate_max, buy_price);\n    if (!isNaN(given_prices[start + 1])) {\n      min_pred = given_prices[start + 1];\n      max_pred = given_prices[start + 1];\n    }\n    predicted_prices.push({\n      min: min_pred,\n      max: max_pred,\n    });\n\n    // Main spike 3\n    min_pred = this.get_price(rate_min, buy_price) - 1;\n    max_pred = predicted_prices[start + 1].max - 1;\n    if (!isNaN(given_prices[start + 2])) {\n      min_pred = given_prices[start + 2];\n      max_pred = given_prices[start + 2];\n    }\n    predicted_prices.push({\n      min: min_pred,\n      max: max_pred,\n    });\n\n    return prob;\n  }\n\n  * generate_pattern_0_with_lengths(\n    given_prices, high_phase_1_len, dec_phase_1_len, high_phase_2_len,\n    dec_phase_2_len, high_phase_3_len) {\n    /*\n        // PATTERN 0: high, decreasing, high, decreasing, high\n        work = 2;\n        // high phase 1\n        for (int i = 0; i < hiPhaseLen1; i++)\n        {\n          sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n        }\n        // decreasing phase 1\n        rate = randfloat(0.8, 0.6);\n        for (int i = 0; i < decPhaseLen1; i++)\n        {\n          sellPrices[work++] = intceil(rate * basePrice);\n          rate -= 0.04;\n          rate -= randfloat(0, 0.06);\n        }\n        // high phase 2\n        for (int i = 0; i < (hiPhaseLen2and3 - hiPhaseLen3); i++)\n        {\n          sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n        }\n        // decreasing phase 2\n        rate = randfloat(0.8, 0.6);\n        for (int i = 0; i < decPhaseLen2; i++)\n        {\n          sellPrices[work++] = intceil(rate * basePrice);\n          rate -= 0.04;\n          rate -= randfloat(0, 0.06);\n        }\n        // high phase 3\n        for (int i = 0; i < hiPhaseLen3; i++)\n        {\n          sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n        }\n    */\n\n    const buy_price = given_prices[0];\n    const predicted_prices = [\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n    ];\n    let probability = 1;\n\n    // High Phase 1\n    probability *= this.generate_individual_random_price(\n      given_prices, predicted_prices, 2, high_phase_1_len, 0.9, 1.4);\n    if (probability == 0) {\n      return;\n    }\n\n    // Dec Phase 1\n    probability *= this.generate_decreasing_random_price(\n      given_prices, predicted_prices, 2 + high_phase_1_len, dec_phase_1_len,\n      0.6, 0.8, 0.04, 0.1);\n    if (probability == 0) {\n      return;\n    }\n\n    // High Phase 2\n    probability *= this.generate_individual_random_price(given_prices, predicted_prices,\n      2 + high_phase_1_len + dec_phase_1_len, high_phase_2_len, 0.9, 1.4);\n    if (probability == 0) {\n      return;\n    }\n\n    // Dec Phase 2\n    probability *= this.generate_decreasing_random_price(\n      given_prices, predicted_prices,\n      2 + high_phase_1_len + dec_phase_1_len + high_phase_2_len,\n      dec_phase_2_len, 0.6, 0.8, 0.04, 0.1);\n    if (probability == 0) {\n      return;\n    }\n\n    // High Phase 3\n    if (2 + high_phase_1_len + dec_phase_1_len + high_phase_2_len + dec_phase_2_len + high_phase_3_len != 14) {\n      throw new Error(\"Phase lengths don't add up\");\n    }\n\n    const prev_length = 2 + high_phase_1_len + dec_phase_1_len +\n      high_phase_2_len + dec_phase_2_len;\n    probability *= this.generate_individual_random_price(\n      given_prices, predicted_prices, prev_length, 14 - prev_length, 0.9, 1.4);\n    if (probability == 0) {\n      return;\n    }\n\n    yield {\n      pattern_number: 0,\n      prices: predicted_prices,\n      probability,\n    };\n  }\n\n  * generate_pattern_0(given_prices) {\n    /*\n        decPhaseLen1 = randbool() ? 3 : 2;\n        decPhaseLen2 = 5 - decPhaseLen1;\n        hiPhaseLen1 = randint(0, 6);\n        hiPhaseLen2and3 = 7 - hiPhaseLen1;\n        hiPhaseLen3 = randint(0, hiPhaseLen2and3 - 1);\n    */\n    for (var dec_phase_1_len = 2; dec_phase_1_len < 4; dec_phase_1_len++) {\n      for (var high_phase_1_len = 0; high_phase_1_len < 7; high_phase_1_len++) {\n        for (var high_phase_3_len = 0; high_phase_3_len < (7 - high_phase_1_len - 1 + 1); high_phase_3_len++) {\n          yield* this.multiply_generator_probability(\n            this.generate_pattern_0_with_lengths(given_prices, high_phase_1_len, dec_phase_1_len, 7 - high_phase_1_len - high_phase_3_len, 5 - dec_phase_1_len, high_phase_3_len),\n            1 / (4 - 2) / 7 / (7 - high_phase_1_len));\n        }\n      }\n    }\n  }\n\n  * generate_pattern_1_with_peak(given_prices, peak_start) {\n    /*\n      // PATTERN 1: decreasing middle, high spike, random low\n      peakStart = randint(3, 9);\n      rate = randfloat(0.9, 0.85);\n      for (work = 2; work < peakStart; work++)\n      {\n        sellPrices[work] = intceil(rate * basePrice);\n        rate -= 0.03;\n        rate -= randfloat(0, 0.02);\n      }\n      sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n      sellPrices[work++] = intceil(randfloat(1.4, 2.0) * basePrice);\n      sellPrices[work++] = intceil(randfloat(2.0, 6.0) * basePrice);\n      sellPrices[work++] = intceil(randfloat(1.4, 2.0) * basePrice);\n      sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n      for (; work < 14; work++)\n      {\n        sellPrices[work] = intceil(randfloat(0.4, 0.9) * basePrice);\n      }\n    */\n\n    const buy_price = given_prices[0];\n    const predicted_prices = [\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n    ];\n    let probability = 1;\n\n    probability *= this.generate_decreasing_random_price(\n      given_prices, predicted_prices, 2, peak_start - 2, 0.85, 0.9, 0.03, 0.05);\n    if (probability == 0) {\n      return;\n    }\n\n    // Now each day is independent of next\n    let min_randoms = [0.9, 1.4, 2.0, 1.4, 0.9, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4];\n    let max_randoms = [1.4, 2.0, 6.0, 2.0, 1.4, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9];\n    for (let i = peak_start; i < 14; i++) {\n      probability *= this.generate_individual_random_price(\n        given_prices, predicted_prices, i, 1, min_randoms[i - peak_start],\n        max_randoms[i - peak_start]);\n      if (probability == 0) {\n        return;\n      }\n    }\n    yield {\n      pattern_number: 1,\n      prices: predicted_prices,\n      probability,\n    };\n  }\n\n  * generate_pattern_1(given_prices) {\n    for (var peak_start = 3; peak_start < 10; peak_start++) {\n      yield* this.multiply_generator_probability(this.generate_pattern_1_with_peak(given_prices, peak_start), 1 / (10 - 3));\n    }\n  }\n\n  * generate_pattern_2(given_prices) {\n    /*\n        // PATTERN 2: consistently decreasing\n        rate = 0.9;\n        rate -= randfloat(0, 0.05);\n        for (work = 2; work < 14; work++)\n        {\n          sellPrices[work] = intceil(rate * basePrice);\n          rate -= 0.03;\n          rate -= randfloat(0, 0.02);\n        }\n        break;\n    */\n\n    const buy_price = given_prices[0];\n    const predicted_prices = [\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n    ];\n    let probability = 1;\n\n    probability *= this.generate_decreasing_random_price(\n      given_prices, predicted_prices, 2, 14 - 2, 0.85, 0.9, 0.03, 0.05);\n    if (probability == 0) {\n      return;\n    }\n\n    yield {\n      pattern_number: 2,\n      prices: predicted_prices,\n      probability,\n    };\n  }\n\n  * generate_pattern_3_with_peak(given_prices, peak_start) {\n\n    /*\n      // PATTERN 3: decreasing, spike, decreasing\n      peakStart = randint(2, 9);\n      // decreasing phase before the peak\n      rate = randfloat(0.9, 0.4);\n      for (work = 2; work < peakStart; work++)\n      {\n        sellPrices[work] = intceil(rate * basePrice);\n        rate -= 0.03;\n        rate -= randfloat(0, 0.02);\n      }\n      sellPrices[work++] = intceil(randfloat(0.9, 1.4) * (float)basePrice);\n      sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n      rate = randfloat(1.4, 2.0);\n      sellPrices[work++] = intceil(randfloat(1.4, rate) * basePrice) - 1;\n      sellPrices[work++] = intceil(rate * basePrice);\n      sellPrices[work++] = intceil(randfloat(1.4, rate) * basePrice) - 1;\n      // decreasing phase after the peak\n      if (work < 14)\n      {\n        rate = randfloat(0.9, 0.4);\n        for (; work < 14; work++)\n        {\n          sellPrices[work] = intceil(rate * basePrice);\n          rate -= 0.03;\n          rate -= randfloat(0, 0.02);\n        }\n      }\n    */\n\n    const buy_price = given_prices[0];\n    const predicted_prices = [\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n    ];\n    let probability = 1;\n\n    probability *= this.generate_decreasing_random_price(\n      given_prices, predicted_prices, 2, peak_start - 2, 0.4, 0.9, 0.03, 0.05);\n    if (probability == 0) {\n      return;\n    }\n\n    // The peak\n    probability *= this.generate_individual_random_price(\n      given_prices, predicted_prices, peak_start, 2, 0.9, 1.4);\n    if (probability == 0) {\n      return;\n    }\n\n    probability *= this.generate_peak_price(\n      given_prices, predicted_prices, peak_start + 2, 1.4, 2.0);\n    if (probability == 0) {\n      return;\n    }\n\n    if (peak_start + 5 < 14) {\n      probability *= this.generate_decreasing_random_price(\n        given_prices, predicted_prices, peak_start + 5, 14 - (peak_start + 5),\n        0.4, 0.9, 0.03, 0.05);\n      if (probability == 0) {\n        return;\n      }\n    }\n\n    yield {\n      pattern_number: 3,\n      prices: predicted_prices,\n      probability,\n    };\n  }\n\n  * generate_pattern_3(given_prices) {\n    for (let peak_start = 2; peak_start < 10; peak_start++) {\n      yield* this.multiply_generator_probability(this.generate_pattern_3_with_peak(given_prices, peak_start), 1 / (10 - 2));\n    }\n  }\n\n  get_transition_probability(previous_pattern) {\n    if (typeof previous_pattern === 'undefined' || Number.isNaN(previous_pattern) || previous_pattern === null || previous_pattern < 0 || previous_pattern > 3) {\n      // Use the steady state probabilities of PROBABILITY_MATRIX if we don't\n      // know what the previous pattern was.\n      // See https://github.com/mikebryant/ac-nh-turnip-prices/issues/68\n      // and https://github.com/mikebryant/ac-nh-turnip-prices/pull/90\n      // for more information.\n      return [4530 / 13082, 3236 / 13082, 1931 / 13082, 3385 / 13082];\n    }\n\n    return PROBABILITY_MATRIX[previous_pattern];\n  }\n\n  * generate_all_patterns(sell_prices, previous_pattern) {\n    const generate_pattern_fns = [this.generate_pattern_0, this.generate_pattern_1, this.generate_pattern_2, this.generate_pattern_3];\n    const transition_probability = this.get_transition_probability(previous_pattern);\n\n    for (let i = 0; i < 4; i++) {\n      yield* this.multiply_generator_probability(generate_pattern_fns[i].bind(this)(sell_prices), transition_probability[i]);\n    }\n  }\n\n  * generate_possibilities(sell_prices, first_buy, previous_pattern) {\n    if (first_buy || isNaN(sell_prices[0])) {\n      for (var buy_price = 90; buy_price <= 110; buy_price++) {\n        const temp_sell_prices = sell_prices.slice();\n        temp_sell_prices[0] = temp_sell_prices[1] = buy_price;\n        if (first_buy) {\n          yield* this.generate_pattern_3(temp_sell_prices);\n        } else {\n          // All buy prices are equal probability and we're at the outmost layer,\n          // so don't need to multiply_generator_probability here.\n          yield* this.generate_all_patterns(temp_sell_prices, previous_pattern);\n        }\n      }\n    } else {\n      yield* this.generate_all_patterns(sell_prices, previous_pattern);\n    }\n  }\n\n  analyze_possibilities() {\n    const sell_prices = this.prices;\n    const first_buy = this.first_buy;\n    const previous_pattern = this.previous_pattern;\n    let generated_possibilities = [];\n    for (let i = 0; i < 6; i++) {\n      this.fudge_factor = i;\n      generated_possibilities = Array.from(this.generate_possibilities(sell_prices, first_buy, previous_pattern));\n      if (generated_possibilities.length > 0) {\n        // console.log(\"Generated possibilities using fudge factor %d: \", i, generated_possibilities);\n        break;\n      }\n    }\n\n    const total_probability = generated_possibilities.reduce((acc, it) => acc + it.probability, 0);\n    for (const it of generated_possibilities) {\n      it.probability /= total_probability;\n    }\n\n    for (let poss of generated_possibilities) {\n      var weekMins = [];\n      var weekMaxes = [];\n      for (let day of poss.prices.slice(2)) {\n        // Check for a future date by checking for a range of prices\n        if (day.min !== day.max) {\n          weekMins.push(day.min);\n          weekMaxes.push(day.max);\n        } else {\n          // If we find a set price after one or more ranged prices, the user has missed a day. Discard that data and start again.\n          weekMins = [];\n          weekMaxes = [];\n        }\n      }\n      if (!weekMins.length && !weekMaxes.length) {\n        weekMins.push(poss.prices[poss.prices.length - 1].min);\n        weekMaxes.push(poss.prices[poss.prices.length - 1].max);\n      }\n      poss.weekGuaranteedMinimum = Math.max(...weekMins);\n      poss.weekMax = Math.max(...weekMaxes);\n    }\n\n    let category_totals = {};\n    for (let i of [0, 1, 2, 3]) {\n      category_totals[i] = generated_possibilities\n        .filter(value => value.pattern_number == i)\n        .map(value => value.probability)\n        .reduce((previous, current) => previous + current, 0);\n    }\n\n    for (let pos of generated_possibilities) {\n      pos.category_total_probability = category_totals[pos.pattern_number];\n    }\n\n    generated_possibilities.sort((a, b) => {\n      return b.category_total_probability - a.category_total_probability || b.probability - a.probability;\n    });\n\n    let global_min_max = [];\n    for (let day = 0; day < 14; day++) {\n      const prices = {\n        min: 999,\n        max: 0,\n      };\n      for (let poss of generated_possibilities) {\n        if (poss.prices[day].min < prices.min) {\n          prices.min = poss.prices[day].min;\n        }\n        if (poss.prices[day].max > prices.max) {\n          prices.max = poss.prices[day].max;\n        }\n      }\n      global_min_max.push(prices);\n    }\n\n    generated_possibilities.unshift({\n      pattern_number: 4,\n      prices: global_min_max,\n      weekGuaranteedMinimum: Math.min(...generated_possibilities.map(poss => poss.weekGuaranteedMinimum)),\n      weekMax: Math.max(...generated_possibilities.map(poss => poss.weekMax))\n    });\n\n    return generated_possibilities;\n  }\n}\n\nexport default Predictor;\n","import React, { useMemo } from 'react';\nimport { Table, ListGroupItem, ListGroup } from 'reactstrap';\nimport styled from 'styled-components';\nimport PropTypes from 'prop-types';\nimport shortid from 'shortid';\nimport Predictor, { PATTERN } from '../../utils/predictions'; // eslint-disable-line\n\nconst PATTERN_DESCRIPTION = [\n  'Fluctuating',\n  'Large spike',\n  'Decreasing',\n  'Small spike',\n  'All patterns',\n];\n\nconst Line = styled.tr`\n  cursor: pointer;\n\n  ${(p) => p.selected && `\n  background-color: #f0e8c0;\n  `}\n\n  td {\n    text-align: center;\n  }\n\n  span.lowest-price {\n    color: #ffc107;\n    font-weight: bold;\n  }\n\n  span.highest-price {\n    color: #28a745;\n    font-weight: bold;\n  }\n\n`;\n\nconst propTypes = {\n  buyPrice: PropTypes.number.isRequired,\n  sellPrices: PropTypes.arrayOf(PropTypes.number).isRequired,\n  displayEstimate: PropTypes.func.isRequired,\n  isFirstTime: PropTypes.bool,\n  selectedLines: PropTypes.arrayOf(PropTypes.object),\n  lastWeekPattern: PropTypes.number,\n};\n\nconst defaultProps = {\n  selectedLines: [],\n  isFirstTime: false,\n  lastWeekPattern: -1,\n};\n\nconst Predictions = ({\n  buyPrice, sellPrices, displayEstimate, isFirstTime, selectedLines, lastWeekPattern,\n}) => {\n  const onClick = (key, min, max) => {\n    displayEstimate(key, min, max);\n  };\n\n  const renderDays = (days) => {\n    // not used yet\n    const { min, max } = days.reduce((acc, val) => {\n      const newObj = { ...acc };\n      if (!acc.max || val.max > acc.max) newObj.max = val.max;\n      if (!acc.min || val.min < acc.min) newObj.min = val.min;\n      return newObj;\n    }, { min: null, max: null });\n\n    const renderValue = (value) => {\n      let className = '';\n      if (value === min) className = 'lowest-price';\n      else if (value === max) className = 'highest-price';\n      return <span className={className}>{value}</span>;\n    };\n\n    return days.map((day) => (\n      <td key={shortid.generate()}>\n        {day.min !== day.max ? (\n          <>\n            {renderValue(day.min)}\n            &nbsp;to&nbsp;\n            {renderValue(day.max)}\n          </>\n        ) : renderValue(day.min)}\n      </td>\n    ));\n  };\n\n  const renderPercentage = (percent) => (Number.isFinite(percent) ? (`${(percent * 100).toPrecision(3)}%`) : 'â€”');\n\n  const renderPatterns = (possibilities) => {\n    if (!possibilities) return [];\n    return possibilities.map((poss) => {\n      // for the additional graphs - we don't need the sunday price\n      const { mins, maxs } = poss.prices.slice(2).reduce((acc, d) => ({\n        mins: [...acc.mins, d.min],\n        maxs: [...acc.maxs, d.max],\n      }), { mins: [], maxs: [] });\n\n      const days = poss.prices.slice(1);\n      const key = JSON.stringify(poss.prices);\n      const isSelected = selectedLines.findIndex((v) => v.key === key) !== -1;\n\n      return (\n        <Line\n          onClick={() => onClick(key, mins, maxs)}\n          key={shortid.generate()}\n          selected={isSelected}\n        >\n          <td>{PATTERN_DESCRIPTION[poss.pattern_number]}</td>\n          <td>{renderPercentage(poss.probability)}</td>\n          {renderDays(days)}\n          <td>{poss.weekGuaranteedMinimum}</td>\n          <td>{poss.weekMax}</td>\n        </Line>\n      );\n    });\n  }\n\n  const renderPatternProbabilities = (possibilities) => {\n    if (!possibilities) return [];\n    let previousPattern = '';\n    return possibilities.reduce((acc, poss) => {\n      if (previousPattern !== poss.pattern_number) {\n        previousPattern = poss.pattern_number;\n        if (!poss.category_total_probability) return [...acc];\n        const newValue = (\n          <ListGroupItem key={poss.pattern_number}>{`${PATTERN_DESCRIPTION[poss.pattern_number]}: ${renderPercentage(poss.category_total_probability)}`}</ListGroupItem>\n        );\n        return [...acc, newValue];\n      }\n      return [...acc];\n    }, []);\n  };\n\n  const possibilities = useMemo(() => {\n    const p = buyPrice === 0 ? NaN : buyPrice;\n    const prices = [p, p, ...sellPrices];\n  \n    const isEmpty = prices.every((s) => !s);\n    if (isEmpty) return null;\n  \n    const predictor = new Predictor(\n      prices,\n      isFirstTime,\n      (PATTERN[lastWeekPattern] || -1),\n    );\n    return predictor.analyze_possibilities();\n  }, [buyPrice, sellPrices, isFirstTime, lastWeekPattern]);\n\n  return (\n    <>\n      <h3>Predictions</h3>\n\n      <div style={{ marginBottom: '20px', display: 'flex', justifyContent: 'center' }}>\n        <ListGroup horizontal=\"lg\">\n          {renderPatternProbabilities(possibilities)}\n        </ListGroup>\n      </div>\n\n      <Table size=\"sm\" hover responsive>\n        <thead>\n          <tr>\n            <th>Pattern</th>\n            <th>%</th>\n            <th>Sunday</th>\n            <th colSpan=\"2\">Monday</th>\n            <th colSpan=\"2\">Tuesday</th>\n            <th colSpan=\"2\">Wednesday</th>\n            <th colSpan=\"2\">Thursday</th>\n            <th colSpan=\"2\">Friday</th>\n            <th colSpan=\"2\">Saturday</th>\n            <th>Guaranteed Min</th>\n            <th>Potential Max</th>\n          </tr>\n        </thead>\n        <tbody>{renderPatterns(possibilities)}</tbody>\n      </Table>\n    </>\n  );\n};\n\nPredictions.propTypes = propTypes;\nPredictions.defaultProps = defaultProps;\n\nexport default Predictions;\n","import React from 'react';\nimport {\n  Table, Input, Button, Container,\n} from 'reactstrap';\nimport PropTypes from 'prop-types';\n\nconst propTypes = {\n  values: PropTypes.arrayOf(PropTypes.shape({\n    when: PropTypes.string,\n    price: PropTypes.number,\n    order: PropTypes.number,\n  })).isRequired,\n  savePrice: PropTypes.func.isRequired,\n  reset: PropTypes.func.isRequired,\n};\n\nconst TablePrices = ({ values, savePrice, reset }) => {\n  const onChange = ({ field, value }) => {\n    savePrice({\n      when: field,\n      price: parseInt(value, 10),\n    });\n  };\n\n  const formateLabelName = (l) => l.trim().replace(' ', '_').toLowerCase();\n\n  const renderInput = (name) => {\n    const v = values.find((val) => val.when === formateLabelName(name));\n    let value = '';\n    if (v) value = v.price === 0 ? '' : v.price;\n    return (\n      <Input\n        type=\"number\"\n        name=\"\"\n        id=\"\"\n        placeholder=\"--\"\n        value={value || ''}\n        onChange={(e) => onChange({\n          field: name,\n          value: e.currentTarget.value,\n        })}\n      />\n    );\n  };\n\n  return (\n    <>\n      <Table borderless size=\"sm\" responsive>\n        <thead>\n          <tr>\n            <th>&nbsp;</th>\n            <th>Monday</th>\n            <th>Tuesday</th>\n            <th>Wednesday</th>\n            <th>Thursday</th>\n            <th>Friday</th>\n            <th>Saturday</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td>AM</td>\n            <td>{renderInput('Mon AM')}</td>\n            <td>{renderInput('tue AM')}</td>\n            <td>{renderInput('Wed AM')}</td>\n            <td>{renderInput('Thu AM')}</td>\n            <td>{renderInput('Fri AM')}</td>\n            <td>{renderInput('Sat AM')}</td>\n          </tr>\n          <tr>\n            <td>PM</td>\n            <td>{renderInput('Mon PM')}</td>\n            <td>{renderInput('Tue PM')}</td>\n            <td>{renderInput('Wed PM')}</td>\n            <td>{renderInput('Thu PM')}</td>\n            <td>{renderInput('Fri PM')}</td>\n            <td>{renderInput('Sat PM')}</td>\n          </tr>\n        </tbody>\n      </Table>\n      <Container style={{ textAlign: 'center' }}>\n        <Button onClick={reset}>Reset</Button>\n      </Container>\n    </>\n  );\n};\n\nTablePrices.propTypes = propTypes;\n\nexport default TablePrices;\n","import React, { useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  FormGroup, Label, Input, Button, Collapse,\n  Card, CardBody, Col,\n} from 'reactstrap';\nimport { PATTERN } from '../../utils/predictions';\n\nconst propTypes = {\n  onChange: PropTypes.func.isRequired,\n  quantity: PropTypes.number,\n  pattern: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  sellPrice: PropTypes.number,\n  sundayPrice: PropTypes.number,\n};\n\nconst defaultProps = {\n  quantity: 0,\n  pattern: -1,\n  sellPrice: 0,\n  sundayPrice: 0,\n};\n\nconst ResultForm = ({\n  quantity,\n  pattern,\n  sellPrice,\n  onChange,\n  sundayPrice,\n}) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const [result, setResult] = useState(null);\n\n  useEffect(() => {\n    const calcResult = () => {\n      const lost = sundayPrice * quantity;\n      const won = sellPrice * quantity;\n      setResult(won - lost);\n    };\n    calcResult();\n  }, [quantity, sellPrice, sundayPrice]);\n\n  const toggle = () => setIsOpen(!isOpen);\n\n  const handleChange = (field) => (e) => onChange({ field, value: e.currentTarget.value });\n\n  const renderForm = () => (\n    <Card>\n      <CardBody>\n        <FormGroup row>\n          <Label for=\"qty\" sm=\"5\">Quantity bought</Label>\n          <Col sm={7}>\n            <Input\n              type=\"number\"\n              name=\"qty\"\n              id=\"qty\"\n              placeholder=\"\"\n              onChange={handleChange('quantity')}\n              value={quantity}\n            />\n          </Col>\n        </FormGroup>\n        <FormGroup row>\n          <Label for=\"sellPrice\" sm=\"5\">Sell price</Label>\n          <Col sm={7}>\n            <Input\n              type=\"number\"\n              name=\"sellPrice\"\n              id=\"sellPrice\"\n              placeholder=\"\"\n              value={sellPrice}\n              onChange={handleChange('sellPrice')}\n            />\n          </Col>\n        </FormGroup>\n        <FormGroup row>\n          <Label for=\"pattern\" sm=\"5\">This week identified pattern</Label>\n          <Col sm={7}>\n            <Input\n              type=\"select\"\n              name=\"pattern\"\n              id=\"pattern\"\n              value={pattern || -1}\n              onChange={handleChange('pattern')}\n            >\n              <option value=\"-1\">unknown</option>\n              {Object.keys(PATTERN).map((key) => (\n                <option key={key} value={key}>{key.replace('_', ' ').toLowerCase()}</option>\n              ))}\n            </Input>\n          </Col>\n        </FormGroup>\n        {(result > 0) && (\n          <FormGroup row>\n            <Label for=\"result\" sm={5}>Total for the week</Label>\n            <Col sm={7}>\n              <Input\n                className={result > 0 ? 'text-success' : 'text-danger'}\n                type=\"string\"\n                name=\"result\"\n                id=\"result\"\n                disabled\n                value={result}\n              />\n            </Col>\n          </FormGroup>\n        )}\n      </CardBody>\n    </Card>\n  );\n\n  return (\n    <>\n      <Button color=\"link\" onClick={toggle} style={{ marginBottom: '1rem' }}>\n        {isOpen ? 'Hide results' : 'Show results'}\n      </Button>\n      <Collapse isOpen={isOpen}>{renderForm()}</Collapse>\n    </>\n  );\n};\n\nResultForm.propTypes = propTypes;\nResultForm.defaultProps = defaultProps;\n\nexport default ResultForm;\n","import React, { useState, useEffect } from 'react';\nimport { useLocation, useHistory } from 'react-router-dom';\nimport ChartistGraph from 'react-chartist';\nimport styled from 'styled-components';\nimport dayjs from 'dayjs';\nimport qs from 'qs';\nimport { ButtonGroup, Button } from 'reactstrap';\nimport Tooltip from 'chartist-plugin-tooltips'; // eslint-disable-line\nimport Chartist from 'chartist';\nimport useLocalStorage from '../../hooks/useLocalStorage';\nimport * as DateUtils from '../../utils/dates';\nimport SundayPriceForm from './SundayPriceForm';\nimport Predictions from './Predictions';\nimport TablePrices from './TablePrices';\nimport ResultForm from './ResultForm';\nimport SectionContainer from '../SectionContainer';\n\nimport 'chartist/dist/chartist.min.css';\nimport 'chartist-plugin-tooltips/dist/chartist-plugin-tooltip.css';\n\nconst Wrapper = styled.div`\n  margin: 20px;\n  `;\n\nconst ChartContainer = styled.div`\n  .ct-series, .ct-point {\n    opacity: .3;\n  }\n\n  .ct-series:last-child .ct-point {\n    opacity: 1;\n    stroke: red;\n  }\n\n  .ct-series:last-child .ct-line {\n    stroke: red;\n    stroke-width: 5px;\n    stroke-dasharray: 10px 20px;\n  }\n\n  .ct-series:last-child {\n    opacity: 1;\n    stroke: red;\n  }\n`;\n\nexport const LABELS = ['Mon AM', 'Mon PM', 'Tue AM', 'Tue PM', 'Wed AM', 'Wed PM', 'Thu AM', 'Thu PM', 'Fri AM', 'Fri PM', 'Sat AM', 'Sat PM'];\n\nconst TurnipsPage = () => {\n  const history = useHistory();\n  const location = useLocation();\n  const [turnips, setTurnips] = useLocalStorage('turnips', {});\n\n  const [currentWeek, setCurrentWeek] = useState(null);\n  const [sundayPrice, setSundayPrice] = useState(0);\n  const [myTownData, setMyTownData] = useState([]);\n  const [isFirstTime, setIsFirstTime] = useState();\n  const [selectedPredictions, setSelectedPredictions] = useState([]);\n\n  const [quantityBought, setQuantityBought] = useState();\n  const [pattern, setPattern] = useState();\n  const [sellPrice, setSellPrice] = useState();\n\n  // last week pattern for the %\n  const [lastWeekPattern, setLastWeekPattern] = useState(null);\n\n  useEffect(() => {\n    // get the week\n    const queryObj = qs.parse(location.search.slice(1));\n    setCurrentWeek(DateUtils.getSundayDateForWeek(queryObj.date || dayjs().format('YYYY-MM-DD')));\n\n    // check if we have data for the previous week and  if we have a pattern\n    const lastWeek = turnips[DateUtils.getPreviousWeek(currentWeek)];\n    if (lastWeek && lastWeek.pattern) {\n      setLastWeekPattern(lastWeek.pattern);\n    } else {\n      setLastWeekPattern(null);\n    }\n\n    const weekValues = turnips[currentWeek];\n    if (weekValues) {\n      setSundayPrice(weekValues.sundayPrice || 0);\n      setMyTownData(weekValues.graph || []);\n      setIsFirstTime(weekValues.isFirstTime || false);\n      setQuantityBought(weekValues.qty || 0);\n      setPattern(weekValues.pattern || -1);\n      setSellPrice(weekValues.sellPrice || 0);\n    } else {\n      setSundayPrice(0);\n      setMyTownData([]);\n      setIsFirstTime(false);\n      setQuantityBought(0);\n      setPattern(-1);\n      setSellPrice(0);\n    }\n  }, [currentWeek, location.search, turnips]);\n\n  const updateLocalStorage = (newWeekValues) => {\n    const oldValue = turnips[currentWeek];\n    const obj = {\n      [currentWeek]: { ...oldValue, ...newWeekValues },\n    };\n    const newObj = { ...turnips, ...obj };\n    setTurnips(newObj);\n  };\n\n  const formateLabelName = (l) => l.trim().replace(' ', '_').toLowerCase();\n\n  const getFormatedData = (defaultValue = null) => LABELS.map((l) => {\n    const value = myTownData.find((d) => d.when === formateLabelName(l));\n    if (value) return value.price || defaultValue;\n    return defaultValue;\n  });\n\n  const getSelectedEstimates = () => selectedPredictions.reduce((acc, val) => {\n    const newObj = [];\n    if (val.min) newObj.push(val.min);\n    if (val.max) newObj.push(val.max);\n    return [...acc, ...newObj];\n  }, []);\n\n  const simpleLineChartData = {\n    labels: LABELS,\n    series: [\n      ...getSelectedEstimates(),\n      getFormatedData(),\n    ],\n  };\n\n  const options = {\n    fullWidth: true,\n    chartPadding: {\n      right: 50,\n    },\n    scaleMinSpace: 20,\n    height: '400px',\n    onlyInteger: true,\n    plugins: [\n      Chartist.plugins.tooltip({\n        anchorToPoint: true,\n        appendToBody: true,\n      }),\n    ],\n  };\n\n  const onSaveSundayPrice = (field, value) => {\n    if (field === 'price') {\n      setSundayPrice(value);\n      updateLocalStorage({ sundayPrice: value });\n    } else if (field === 'firstTime') {\n      setIsFirstTime(value);\n      updateLocalStorage({ isFirstTime: value });\n    }\n  };\n\n  const addNewPrice = ({ when, price }) => {\n    const formatedWhen = formateLabelName(when);\n    const index = myTownData.findIndex((v) => v.when === formatedWhen);\n    const newValue = {\n      when: formatedWhen,\n      price: price === 0 ? null : price,\n      order: LABELS.indexOf(when),\n    };\n\n    const newData = [...myTownData];\n    if (index === -1) {\n      newData.push(newValue);\n    } else {\n      newData.splice(index, 1, newValue);\n    }\n\n    setMyTownData(newData);\n    updateLocalStorage({ graph: newData });\n  };\n\n  const changeWeek = (next) => {\n    const newDate = next\n      ? DateUtils.getNextWeek(currentWeek)\n      : DateUtils.getPreviousWeek(currentWeek);\n    history.push(`${location.pathname}?date=${newDate}`);\n  };\n\n  const displayEstimate = (key, min, max) => {\n    const index = selectedPredictions.findIndex((v) => v.key === key);\n    if (index === -1) {\n      const newData = [...selectedPredictions, { key, min, max }];\n      setSelectedPredictions(newData);\n    } else {\n      const newData = [...selectedPredictions];\n      newData.splice(index, 1);\n      setSelectedPredictions(newData);\n    }\n  };\n\n  const resetPrices = () => {\n    setMyTownData([]);\n    updateLocalStorage({ graph: [] });\n  };\n\n  const onChangeResultForm = ({ field, value }) => {\n    const intValue = parseInt(value, 10);\n    switch (field) {\n      case 'pattern':\n        setPattern(value);\n        updateLocalStorage({ pattern: value });\n        break;\n      case 'quantity':\n        setQuantityBought(intValue);\n        updateLocalStorage({ qty: intValue });\n        break;\n      case 'sellPrice':\n        setSellPrice(intValue);\n        updateLocalStorage({ sellPrice: intValue });\n        break;\n      default: break;\n    }\n  };\n\n  return (\n    <SectionContainer>\n      <Wrapper style={{ display: 'flex', flexDirection: 'row' }}>\n        <h3>My town prices</h3>\n        <ButtonGroup style={{ marginLeft: '20px' }}>\n          <Button onClick={() => changeWeek(false)} size=\"sm\" color=\"link\">\n            {'<'}\n            {' '}\n            Previous week\n          </Button>\n          <Button onClick={() => changeWeek(true)} size=\"sm\" color=\"link\">\n            Next week\n            {' '}\n            {'>'}\n          </Button>\n        </ButtonGroup>\n      </Wrapper>\n      <Wrapper style={{ fontStyle: 'italic' }}>\n        This tool is based on\n        {' '}\n        <a href=\"https://twitter.com/_Ninji\" rel=\"noopener noreferrer\" target=\"_blank\">Ninji</a>\n        {'\\'s '}\n        data mining.\n      </Wrapper>\n      <Wrapper>\n        <SundayPriceForm\n          onChange={onSaveSundayPrice}\n          currentWeek={currentWeek}\n          value={sundayPrice}\n          isFirstTime={isFirstTime}\n        />\n      </Wrapper>\n      <Wrapper>\n        <ResultForm\n          onChange={onChangeResultForm}\n          quantity={quantityBought}\n          pattern={pattern}\n          sellPrice={sellPrice}\n          sundayPrice={sundayPrice}\n        />\n      </Wrapper>\n      <Wrapper>\n        <TablePrices values={myTownData} savePrice={addNewPrice} reset={resetPrices} />\n      </Wrapper>\n      <ChartContainer>\n        <ChartistGraph data={simpleLineChartData} type=\"Line\" options={options} />\n      </ChartContainer>\n      <Wrapper>\n        <Predictions\n          buyPrice={sundayPrice}\n          sellPrices={getFormatedData(NaN)}\n          displayEstimate={displayEstimate}\n          isFirstTime={isFirstTime}\n          selectedLines={selectedPredictions}\n          lastWeekPattern={lastWeekPattern}\n        />\n      </Wrapper>\n    </SectionContainer>\n  );\n};\n\nexport default TurnipsPage;\n"],"sourceRoot":""}